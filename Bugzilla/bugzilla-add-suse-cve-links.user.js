// ==UserScript==
// @name        Bugzilla - Add SUSE CVE page link
// @namespace   SUSE SecTools
// @match       https://bugzilla.suse.com/show_bug.cgi?*
// @match       https://bugzilla.opensuse.org/show_bug.cgi?*
// @run-at      document-end
// @grant       none
// @version     1.0.9
// @author      gsonnu
// @description Add links to SUSE CVE pages in title and comments
// ==/UserScript==


(function() {
    let replacers = [
        {
            regex: /CVE-[0-9]{4}-[0-9]*/gi,
            processMatch: replaceCVE
        }
    ]

    // title & alias
    replaceTextWithUrls(document.querySelector('#field_label_alias ~ td'), replacers);
    replaceTextWithUrls(document.querySelector('#alias_nonedit_display'), replacers);
    replaceTextWithUrls(document.querySelector('#short_desc_nonedit_display'), replacers);
    replaceTextWithUrls(document.querySelector('#cvss-score-table'), replacers);

    // comments
    document.querySelectorAll('.bz_comment_text').forEach(e => replaceTextWithUrls(e, replacers));


    function createAnchor(url, text) {
        let link = document.createElement('a');
        link.setAttribute('href', url);
        link.textContent = text;

        return link;
    }

    function createTextNode(text) {
        if (text == null || typeof(text) === 'undefined')
            return null;

        return document.createTextNode(text);
    }

    function replaceCVE(match) {
        return {anchor: createAnchor(`https://www.suse.com/security/cve/${match[0]}.html`, match[0]),
                startIndex: match.index,
                endIndex: match.index + match[0].length};
    }

    function replaceText(elem, spec) {
        let text = elem.textContent;
        let parent = elem.parentNode;
        let index = 0;
        let match = null;

        while (match = spec.regex.exec(text)) {
            let info = spec.processMatch(match);

            // add text before, if any
            parent.insertBefore(createTextNode(text.slice(index, info.startIndex)), elem);

            // add CVE as link
            parent.insertBefore(info.anchor, elem);

            // update index
            index = info.endIndex;
        }

        // no substitutions were made, return
        if (index === 0)
            return;

        // add remaining text, if any
        if (index < (text.length - 1))
            parent.insertBefore(createTextNode(text.slice(index)), elem);

        parent.removeChild(elem);
    }

    function replaceTextWithUrls(elem, specs) {
        if (!elem)
            return;

        for (let spec of specs) {
            // only replace text in text nodes
            Array.from(elem.childNodes).filter(x => x.nodeType === 3).forEach(e => replaceText(e, spec));
        }
    }

})();
